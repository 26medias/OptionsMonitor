
var _				= require('underscore');
var express			= require('express');
var getCLIArgs 		= require('argcli');
var pstack			= require('pstack');
var fstool			= require('fs-tool');
var path 			= require('path');
var mongoPool 		= require('mongo-simplified');
var bowerdep 		= require('bowerdep');
var asyncReplace 	= require('async-replace');
var cachr			= require('cachr');
var fs				= require('fs');
var os				= require('os');
var pkgcloud		= require('pkgcloud');
var bodyParser		= require('body-parser');
var uuid 			= require('./uuid.js');
var nodecrypto 		= require('crypto');
var multer			= require('multer');
var cookieParser	= require('cookie-parser');
var nameGenerator	= require('project-name-generator');
var favicon			= require('serve-favicon');
var md5File			= require('md5-file');
var nunjucks		= require("nunjucks");
var cfcors			= require("cloudfile-cors");
var compression		= require('compression');
var shortid			= require('shortid');
var mobileDetect	= require('mobile-detect');
var spiderDetector	= require('spider-detector')

var ftl = function(options) {
	var scope = this;
	
	this.options	 	= _.extend({
		port:		80,
		directories:	['app/'],
		mongo:	{
			string:		'mongodb://127.0.0.1:27017/ftl',
			poolSize:	10
		},
		bower:	{
			root:	'bower_components/'
		},
		cdn:	{
			active:		false,
			provider: 	'rackspace',
			authUrl: 	"https://identity.api.rackspacecloud.com",
			region: 	"IAD",
			username: 	'',
			password: 	'',
			container:	''
		},
		confCollection:	'_ftl',
		upload:	{
			directory:	'upload'
		},
		sharedConf:	{},	// Shared conf, loaded from the DB
		localGroup:	{
			confirm:	5000,	// Confirm that the leader is still in charge
			elect:		10000,	// Elect a new leader
			ttl:		30000
		},
		TTL:	{
			sharedConf:	30000
		},
		electable:		true
	}, options);
	
	this._jsonPrefix	= '__JSON__';
	
	this.root			= this.options.root;
	
	this.modules		= {};
	
	this.crons			= {};
	
	this.files			= {};
	
	this.renderPlugins	= [];
	
	this.intervals		= {};
	
	this.data			= {};
	
	this.routes			= [];
	
	this.isGroupLeader	= false;
	
	this.plugins		= {
		'before-process':	[],
		'before-response':	[],
	};
	
	this.cache			= new cachr({
		TTL:	10
	});
	
	this.formats	= {
		reset:	37,
		color:	{
			red:	31,
			green:	32,
			yellow:	33,
			blue:	34,
			magenta:35,
			cyan:	36,
			white:	37
		},
		bg:	{
			red:	41,
			green:	42,
			yellow:	43,
			blue:	44,
			magenta:45,
			cyan:	46,
			white:	47
		}
	}
	this.log			= {
		sys:	function() {
			if (scope.options.disableLogs) {
				return false;
			}
			var args	= Array.prototype.slice.call(arguments);
			var output	= scope.log.format('bg.red', '/!\ FTL /!\\')+'  ';
			_.each(args, function(arg) {
				if (typeof arg == "object") {
					output	+= JSON.stringify(arg,null,4);
				} else {
					output	+= arg;
				}
			});
			console.log(output);
			return true;
		},
		log:	function() {
			if (scope.options.disableLogs) {
				return false;
			}
			var args	= Array.prototype.slice.call(arguments);
			var output	= scope.log.format('bg.blue', args[0])+' ';
			output	+= scope.log.format('bg.green', args[1])+' ';
			args	= args.slice(2);
			_.each(args, function(arg) {
				if (typeof arg == "object") {
					output	+= JSON.stringify(arg,null,4)+' ';
				} else {
					output	+= arg+' ';
				}
			});
			console.log(output);
			return true;
		},
		response:	function() {
			if (scope.options.disableLogs) {
				return false;
			}
			var args	= Array.prototype.slice.call(arguments);
			console.log("\033[35m");
			_.each(args, function(arg) {
				console.log(JSON.stringify(arg,null,4));
			});
			console.log("\033[37m");
			return true;
		},
		info:	function() {
			if (scope.options.disableLogs) {
				return false;
			}
			var args	= Array.prototype.slice.call(arguments);
			console.log("\033[32m");
			_.each(args, function(arg) {
				console.log(JSON.stringify(arg,null,4));
			});
			console.log("\033[37m");
			return true;
		},
		error:	function() {
			if (scope.options.disableLogs) {
				return false;
			}
			var args	= Array.prototype.slice.call(arguments);
			console.log("\033[31m");
			_.each(args, function(arg) {
				console.log(JSON.stringify(arg,null,4));
			});
			console.log("\033[37m");
			return true;
		},
		format:	function(jpath, input) {
			var formatValue	= scope.jpath(jpath, scope.formats);
			if (!formatValue) {
				console.log("! Missing format: ", jpath);
				return input;
			}
			if (typeof input == "object") {
				return "\033["+formatValue+"m"+JSON.stringify(input, null, 4)+"\033[37m\033[40m";
			}
			return "\033["+formatValue+"m"+input+"\033[37m\033[40m";
		}
	};
	
	this.bowerdep	= new bowerdep({
		root:	path.normalize(this.root+'/'+this.options.bower.root)
	});
	
	this.nunjucks	= nunjucks;	// Share the ref
};

ftl.prototype.start = function() {
	var scope	= this;
	
	// Create the app
	this.app	= express();
	
	// Timer
	this.app.use(function (req, res, next) {
		res._requestStarted	= new Date();
		next();
	});
	
	this.app.use(bodyParser.json());
	this.app.use(cookieParser());
	this.app.use(favicon(this.dir('/favicon.ico')));
	this.app.use(bodyParser.urlencoded({ extended: true }));
	this.app.use(compression());
	
	this.app.use(express.static(path.normalize(this.root+'/bower_components')));
	
	// Custom Cookie parser
	this.app.use(function (req, res, next) {
		try {
			if (req.cookies && req.cookies.user) {
				if (req.cookies.user.substr(0, scope._jsonPrefix.length) == scope._jsonPrefix) {
					req.cookies.user = JSON.parse(req.cookies.user.substr(scope._jsonPrefix.length));
				}
			}
			req.getCookie = function(name) {
				var cookieValue	= req.cookies[name];
				if (!cookieValue) {
					return null;
				}
				if (cookieValue.substr(0, "__JSON__".length) == "__JSON__") {
					cookieValue = JSON.parse(cookieValue.substr("__JSON__".length));
				}
				return cookieValue;
			};
		} catch (e) {
			console.log("Invalid JSON in cookie",req.cookies.user);
		}
		next();
	});
	
	// Spider Detection
	this.app.use(spiderDetector.middleware())
	
	// Mobile Detection
	this.app.use(function (req, res, next) {
		var md = new mobileDetect(req.headers['user-agent']);
		
		res.mobile	= md.mobile();
		res.os		= md.os();
		res.md		= md;
		
		// For apps:
		//app:iPhone 5s, IOS 2.0.2, app 1.3.10, en, 320x568
		//app:[camelcase device name] [device version], [camelcase OS name] [OS version], app [app version], [locale], [screen size]
		
		next();
	});
	
	// Proper IP
	this.app.use(function (req, res, next) {
		var ipAddr = req.headers["x-forwarded-for"];
		
		//scope.log.log("IP", "x-forwarded-for", ipAddr);
		
		if (ipAddr){
			var list	= ipAddr.split(",");
			ipAddr		= list[0];
		} else {
			ipAddr		= req.connection.remoteAddress;
		}
		req.userIP	= ipAddr;
		
		//scope.log.log("IP", "req.userIP", req.userIP);
		next();
	});
	
	
	var stack	= new pstack({
		progress:	false,//'Starting...',
		async:		false
	});
	
	// Extend the settings from the ENV
	stack.add(function(done) {
		scope.extendFromEnv(function() {
			done();
			return true;
		});
		return true;
	});
	
	// Slug Support
	stack.add(function(done) {
		//scope.log.log("Dependencies","Slug","scope.options.local",scope.options.local);
		if (!scope.options.local) {
			fstool.file.exists(scope.dir('slug.json'), function(exists) {
				
				//scope.log.log("Dependencies","Slug","Exists: ",exists);
				
				if (!exists) {
					// No slug
					done();
				} else {
					// There's a slug
					fstool.file.readJson(scope.dir('slug.json'), function(slugData) {
						//console.log("slugData.cdn",slugData.cdn);
						if (slugData.cdn && scope.options.cdn && scope.options.cdn.alias) {
							scope.options.cdn.alias.libs	= slugData.cdn;
						}
						done();
						return false;
					});
				}
			});
		} else {
			done();
		}
		return true;
	});
	
	// Start the MongoDB pool
	stack.add(function(done) {
		
		if (scope.options.mongo) {
			//scope.log.info("Mongo:", scope.options.mongo);
			console.log("** FTL: Mongo: Connecting...", scope.options.mongo);
			// Track the DB response time
			scope.options.mongo.latency = {
				max:		scope.options.latency.mongo,
				onAlert:	function(ms, op, options) {
					//scope.log.sys("");
					// Save the latency to check it out
					if (scope.options.latency && scope.options.latency.mongo && options.collection && options.collection !== 'latencylogs') {
						
						scope.log.sys("DB LATENCY ALERT: ", scope.log.format('bg.magenta', ms+"ms"), " on ", scope.log.format('bg.magenta', op), " (",scope.log.format('color.yellow', options.collection),")");
						
						//scope.log.response("options",options);
						
						if (options.query) {
							options.query	= JSON.stringify(options.query);
						}
						if (options.data) {
							options.data	= JSON.stringify(options.data);
						}
						if (options.rules) {
							options.rules	= JSON.stringify(options.rules);
						}
						
						scope.mongo.insert({
							collection:	'latencylogs',
							data:	{
								id:			scope.sid(),
								type:		'mongo',
								date:		new Date(),
								ms:			ms,
								op:			op,
								data:		options,
								bookmarked:	false
							}
						}, function(a,b) {
							
						});
					}
					
				}
			};
			scope.mongo	= new mongoPool(scope.options.mongo);
			scope.mongo.init(function() {
				console.log("** FTL: Mongo: \033[32m Success \033[37m");
				done();
				return true;
			});
		} else {
			console.log("** FTL: Mongo: \033[32m Skipped \033[37m");
			done();
			return true;
		}
		return true;
	});
	
	// Init the shared config
	
	stack.add(function(done) {
		console.log("** FTL: Local Group: Creating...");
		scope.setupLocalGroup();
		console.log("** FTL: Local Group: \033[32m Success \033[37m");
		done();
		/*
		scope.refreshSharedConf(function() {
			done();
			
			// Setup the timer
			setInterval(function() {
				scope.refreshSharedConf(function() {});
			}, scope.options.TTL.sharedConf*1000);
			
			// Setup the localGroup with a random delay to prevent leader fights
			scope.setupLocalGroup();
		});
		*/
		return true;
	});
	
	
	// Setup the CDN connection
	stack.add(function(done) {
		console.log("** FTL: CDN: Connecting...");
		scope.cdnClient	= pkgcloud.storage.createClient(scope.options.cdn);
		if (scope.options.cloudfile) {
			scope.cfcors	= new cfcors({
				username:	scope.options.cloudfile.username,
				apiKey:		scope.options.cloudfile.apiKey
			}, function(client, authtoken) {
				//console.log("\n\nauthtoken:\n", authtoken);
				return true;
			});
		}
		console.log("** FTL: CDN: \033[32m Success \033[37m");
		done();
		return true;
	});
	
	// Map the bower libraries
	stack.add(function(done) {
		console.log("** FTL: Bower: Mapping...");
		scope.bowerdep.map(function() {
			console.log("\n** FTL: Bower: \033[32m Success \033[37m");
			done();
			return true;
		});
		return true;
	});
	
	// Upload the new static files to the CDN
	stack.add(function(done) {
		if (scope.options.dependencies.cdn) {
			console.log("** FTL: Static CDN checking (background)");
			scope.staticToCDN(function() {
				console.log("** FTL: Static CDN: \033[32m Success \033[37m");
				return true;
			});
			done();
		} else {
			done();
		}
		return true;
	});
	
	// List the directories
	_.each(this.options.directories, function(rootDirectory) {
		stack.add(function(done) {
			console.log("** FTL: Directory Listing: Searching...");
			fstool.directory.list(path.normalize(scope.root+'/'+rootDirectory), function(directories) {
				_.each(directories, function(directory) {
					scope.files[directory]	= {
						_path:	path.normalize(scope.root+'/'+rootDirectory+'/'+directory),
						files:	[]
					};
					return true;
				});
				console.log("** FTL: Directory Listing: \033[32m Success \033[37m");
				done();
				return true;
			});
			return true;
		});
		return true;
	});
	
	// Load the add-ons
	stack.add(function(done) {
		//console.log("** FTL: Add-ons: Searching...");
		var loadStack	 = new pstack({
			progress:	false, //'Loading the add-ons...',
			async:		false
		});
		
		_.each(scope.files, function(dir, rootDirectory) {
			loadStack.add(function(cb) {
				//console.log("** FTL: Add-ons: \033[33m "+dir._path+" \033[37m");
				fstool.file.list(path.normalize(dir._path), function(files) {
					if (files.length==0) {
						cb();
					} else {
						var reqStack	 = new pstack({
							progress:	false,
							async:		false
						});
						_.each(files, function(file) {
							scope.files[rootDirectory].files.push(path.normalize(dir._path+'/'+file));
							reqStack.add(function(onload) {
								//console.log("** FTL: Add-ons: --- \033[33m "+file+" \033[37m");
								require(path.normalize(dir._path+'/'+file))(scope, onload);
								return true;
							});
							return true;
						});
						reqStack.start(cb);
					}
					return true;
				});
				return true;
			});
		});
		
		loadStack.start(function() {
			//console.log("** FTL: Add-ons: \033[32m Success \033[37m");
			done();
			return true;
		});
		return true;
	});
	
	
	// 404 page
	stack.add(function(done) {
		if (process.env.PAGE_404_URL) {
			scope.app.use(function(req, res, next) {
				fstool.file.read(process.env.PAGE_404_URL, function(file) {
					res.set("Content-Type", "text/html");
					res.status(404).send(file);
					return true;
				});
				return true;
			});
		}
		done();
		return true;
	});
	
	stack.start(function() {
		//scope.app.use(express.static(path.normalize(scope.root+'/bower_components')));
		console.log("");
		console.log("");
		console.log("  __ _   _        __                                             _    ");
		console.log(" / _| |_| |      / _|_ __ __ _ _ __ ___   _____      _____  _ __| | __");
		console.log("| |_| __| |_____| |_| '__/ _` | '_ ` _ \\ / _ \\ \\ /\\ / / _ \\| '__| |/ /");
		console.log("|  _| |_| |_____|  _| | | (_| | | | | | |  __/\\ V  V / (_) | |  |   < ");
		console.log("|_|  \\__|_|     |_| |_|  \\__,_|_| |_| |_|\\___| \\_/\\_/ \\___/|_|  |_|\\_\\");
		console.log("                                                              port "+scope.options.port);
		console.log("");
		console.log("");
		
		scope.server	= scope.app.listen(scope.options.port, function () {
			scope.log.info("FTL Framework Started", "Port "+scope.options.port);
		});
		return true;
	});
	
	return this;
};

ftl.prototype.extendFromEnv = function(callback) {
	var scope = this;
	
	var envStack = new pstack();
	
	if (process.env.DYNO) {
		// It's on heroku, we process the actual env
		// Do nothing
		console.log("-- LOCATION: Heroku");
	} else {
		console.log("-- LOCATION: Local");
		envStack.add(function(done) {
			// Load from the .env file
			fstool.file.read(scope.dir('/.env'), function(endData) {
				// split in lines
				var lines	= endData.split('\r\n');
				
				// Update the local env
				var vars	= _.map(lines, function(line) {
					var parts	= line.split('=');
					var val = parts.slice(1).join('=');
					
					process.env[parts[0]]	= val;
					return {
						id:		parts[0],
						value:	val
					}
				});
				
				//scope.log.response("vars", vars);
				
				//scope.log.info("process.env",process.env);
				done();
				return true;
			});
			return true;
		});
	}
	
	// Merge the ENV
	envStack.add(function(done) {
		
		//scope.log.response("process.env", process.env);
		
		_.each(process.env, function(v, k) {
			//scope.log.info("process.env",v,k);
			// Split
			var parts	= k.split('.');
			//scope.log.response("parts", parts);
			
			if (parts[0]	== 'settings') {
				//scope.log.info("process.env",v,k);
				var localCopy	= JSON.parse(JSON.stringify(scope.options));
				var pointer		= localCopy;
				_.each(parts, function(part, n) {
					if (n==0) {
						return true;
					}
					if (!pointer.hasOwnProperty(part)) {
						pointer[part]	= {};
					}
					if (n==parts.length-1) {
						//pointer	= pointer[part];
						// Last part
						pointer[part]	= v;
						switch (pointer[part]) {
							case "true":
								pointer[part]	= true;
							break;
							case "false":
								pointer[part]	= false;
							break;
						}
						
						//console.log("##### ");
						//console.log("##### TEST", part, pointer[part], new RegExp('([^0-9]+)','gmi').test(pointer[part]));
						//console.log("##### ");
						
						//Fix to replace by a regex
						if (new RegExp('([^0-9]+)','gmi').test(pointer[part])) {
							// Contain more than numbers
							// Do nothing
						} else {
							// Only contains numbers, so we parse it into a float
							pointer[part]	= parseInt(pointer[part]);
							//console.log("----> CONVERTING", part, pointer[part]);
						}
						//scope.log.info("pointer", k, v, pointer, localCopy);
						// Save the conf
						scope.options	= localCopy;
						//console.log("pointer",pointer);
					} else {
						pointer	= pointer[part];
					}
					return true;
				});
			}
			return true;
		});
		done();
		return true;
		//scope.log.info("scope.options", scope.options);
		//console.log("scope.options",scope.options);
	});
	
	envStack.start(function() {
		callback();
		return true;
	});
};

ftl.prototype.jpath = function(jpath, obj) {
	var parts		= jpath.split('.');
	var localCopy	= JSON.parse(JSON.stringify(obj));
	var pointer		= localCopy;
	_.each(parts, function(part, n) {
		if (!pointer.hasOwnProperty(part)) {
			return null;
		}
		pointer	= pointer[part];
		return true;
	});
	return pointer;
}

ftl.prototype.dir = function(dirpath) {
	return path.normalize(this.root+'/'+dirpath);
};

ftl.prototype.setupLocalGroup = function(dirpath) {
	var scope	= this;
	
	if (!this.options.localGroup) {
		this.options.localGroup	= {};
	}
	if (!this.options.localGroup.check) {
		this.options.localGroup.check	= 30000;
	}
	if (!this.options.localGroup.keepALive) {
		this.options.localGroup.keepALive	= 20000;
	}
	if (!this.options.localGroup.ttl) {
		this.options.localGroup.ttl		= 60000;
	}
	
	this.localGroupName	= nameGenerator({words: 2}).dashed;
	
	/*
		Check if the leader position has expired
			Valid:
				Do nothing
			Expired:
				Take over
	*/
	
	scope.log.log("Leader "+this.localGroupName, "Check", scope.log.format('bg.yellow',(this.options.localGroup.check/1000).toFixed(2)+"sec"));
	scope.log.log("Leader "+this.localGroupName, "KeepALive", scope.log.format('bg.yellow',(this.options.localGroup.keepALive/1000).toFixed(2)+"sec"));
	scope.log.log("Leader "+this.localGroupName, "TTL", scope.log.format('bg.yellow',(this.options.localGroup.ttl/1000).toFixed(2)+"sec"));
	
	var check	= function() {
		if (!scope.options.mongo) {
			return false;
		}
		// Check if there is a claimed leader position
		scope.mongo.get({
			collection:	'_ftl',
			query:		{
				type:		'leader',
				expires:	{
					$gt:	new Date()
				}
			},
			fields:	{
				name:	true
			}
		}, function(leader) {
			
			//scope.log.info("leader:", leader);
			
			if (!leader && scope.options.electable) {
				scope.log.sys("There is no leader!");
				// If there is no leader
				// Take over
				// Register our dominance
				scope.mongo.update({
					collection:	'_ftl',
					query:		{
						type:	'leader'
					},
					data:	{
						$set:	{
							name:		scope.localGroupName,
							elected:	new Date(),
							expires:	new Date((new Date().getTime())+parseInt(scope.options.localGroup.ttl))
						}
					}
				}, function() {
					return true;
				});
			} else {
				// There is a leader
				// Are we the leader?
				if (leader.name == scope.localGroupName) {
					// We are the leader!
					if (!scope.isGroupLeader) {
						scope.log.sys("You ("+scope.localGroupName+") are now the process leader!");
					}
					scope.isGroupLeader	= true;
					//scope.log.info("I am the leader");
					
				} else {
					// Do nothing.. Submit to the leader...
					//scope.log.info("I am not the leader");
				}
			}
		});
		return true;
	};
	
	check();
	
	this.intervals.localGroupCheck	= setInterval(function() {
		check();
		return true;
	}, parseInt(this.options.localGroup.check));
	
	
	this.intervals.localGroupKeepALive	= setInterval(function() {
		if (scope.isGroupLeader) {
			scope.mongo.update({
				collection:	'_ftl',
				query:		{
					type:	'leader'
				},
				data:	{
					$set:	{
						name:		scope.localGroupName,
						expires:	new Date((new Date().getTime())+parseInt(scope.options.localGroup.ttl))
					}
				}
			}, function() {
				return true;
			});
		}
		return true;
	}, parseInt(this.options.localGroup.keepALive));
	
	return this;
};

ftl.prototype.refreshSharedConf = function(done) {
	var scope	= this;
	
	// Load the config
	scope.mongo.find({
		collection:	'_ftl',
		query:	{
			type:	'sharedConf'
		}
	}, function(response) {
		if (response.length > 0) {
			// Load the sharedConf, merge with the options
			var sharedConf	= response[0].data;
			
			// Merged with the local sharedConf
			_.each(sharedConf, function(subconf, key) {
				if (_.isObject(subconf)) {
					if (!scope.options.sharedConf.hasOwnProperty(key)) {
						scope.options.sharedConf[key]	= {};
					}
					_.each(subconf, function(value, subkey) {
						scope.options.sharedConf[key][subkey]	= value;
						return true;
					});
				} else {
					scope.options.sharedConf[key]	= subconf;
				}
				return true;
			});
			
			// Merge with the options
			_.each(scope.options.sharedConf, function(value, key) {
				scope.options[key]	= value;
				return true;
			});
			
			done();
			// In the background:
			// Update the db with the new version
			scope.mongo.update({
				collection:	'_ftl',
				query:	{
					type:	'sharedConf'
				},
				data:	{
					$set: {
						updated:	new Date(),
						data:		scope.options.sharedConf
					}
				}
			}, function() {
				return true;
			});
		} else {
			// Merge with the options
			_.each(scope.options.sharedConf, function(value, key) {
				scope.options[key]	= value;
				return true;
			});
			
			done();
			// In the background:
			// Save the sharedConf
			scope.mongo.update({
				collection:	'_ftl',
				query:	{
					type:	'sharedConf'
				},
				data:	{
					$set: {
						updated:	new Date(),
						data:		scope.options.sharedConf
					}
				}
			}, function() {
				return true;
			});
		}
		return true;
	});
	return this;
};

ftl.prototype.staticToCDN = function(callback, options) {
	var scope = this;
	
	options = _.extend({
		query:	{}
	}, options);
	
	if (!scope.options.cdn || !scope.options.cdn.check) {
		callback();
		return false;
	}
	/*
		List the files
		Compute the MD5 for each
		Compute the global MD5
		Publish to CDN
	*/
	var opStack = new pstack();
	
	var md5		= {};
	var md5s	= [];
	var gmd5	= '';
	
	// Calculate the MD5
	opStack.add(function(done) {
		var md5Stack = new pstack();
		
		//scope.log.info("scope.bowerdep.files", scope.bowerdep.files);
		
		var publishableFiles	= scope.bowerdep.publishableFiles();
		
		//fstool.file.writeJson(scope.dir('/publishableFiles.json'), publishableFiles, function() {});
		//scope.log.info("publishableFiles", publishableFiles);
		
		_.each(publishableFiles, function(files, lib) {
			//scope.log.info(lib, files);
			_.each(files, function(file) {
				md5Stack.add(function(completed) {
					/*
					if (file == 'C:\\www\\htdocs\\git\\node-fw\\bower_components\\ui-kit\\components\\chart-bars\\chart-bars.html') {
						scope.log.log("~~DEBUG", "file", file);
					}
					*/
					md5File(file, function (error, sum) {
						/*if (file == 'C:\\www\\htdocs\\git\\node-fw\\bower_components\\ui-kit\\components\\chart-bars\\chart-bars.html') {
							scope.log.log("~~DEBUG", "error", error);
							scope.log.log("~~DEBUG", "sum", sum);
						}*/
						if (error) {
							console.log("MD5 ERROR on ", file, ':\n', error);
							completed();
							return true;
						}
						md5[sum]	= file;
						md5s.push(sum);
						completed();
						return true;
					});
					return true;
				});
				return true;
			});
			return true;
		});
		
		md5Stack.start(function() {
			//fstool.file.writeJson(scope.dir('/md5.json'), md5, function() {});
			gmd5	= scope.md5(md5s.sort().join(''));
			done();
			return true;
		});
		return true;
	});
	
	
	// Check for unpublished md5s
	opStack.add(function(done) {
		
		/*var query	= _.extend({
			type:	'cdn-cache',
			domain:	scope.options.cdn.alias.libs,
			md5:	{
				$in:	md5s
			}
		}, options);*/
		
		var query	= {
			type:	'cdn-cache',
			domain:	scope.options.cdn.alias.libs,
			md5:	{
				$in:	md5s
			}
		};
		
		//scope.log.log("staticToCDN", "options", query);
		//scope.log.log("staticToCDN", "Query", query);
		
		scope.mongo.find({
			collection:	'cdncache',
			fields:	{
				_id:		false
			},
			query:		query
		}, function(found) {
			
			scope.log.log("staticToCDN", "found", found.length);
			
			var foundMd5s	= _.map(found, function(item) {
				return item.md5;
			});
			
			var notFound	= _.filter(md5s, function(item) {
				return !_.contains(foundMd5s, item);
			});
			
			scope.log.sys(notFound.length," files need to be uploaded to the CDN");
			
			// Nothing that is not on the CDN already...
			if (notFound.length==0) {
				done();
				return true;
			}
			/*console.log("");
			console.log("");
			console.log("");
			console.log("");
			console.log("");
			console.log("");
			console.log("Static files not on CDN:",notFound.length);
			console.log("");
			console.log("");
			console.log("");
			console.log("");
			console.log("");
			console.log("");*/
			/*
			scope.log.info({
				found:		found,
				notFound:	notFound,
				md5s:		md5s
			});
			*/
			
			// Upload the missing libs
			var uploadList = [];
			
			_.each(notFound, function(md5hash) {
				var local		= md5[md5hash];
				var staticpath	= path.relative(path.normalize(scope.root+'/bower_components'), md5[md5hash]).replace(/\\/gm, '/');
				var cdnpath		= staticpath;
				uploadList.push([
					local,
					cdnpath,
					{
						md5:		md5hash,
						local:		local,
						staticpath:	staticpath,
						cdnpath:	cdnpath
					}
				]);
				return true;
			});
			
			///scope.log.info("uploadList", uploadList);
			
			
			scope.upload(scope.options.cdn.container.libs, uploadList, function(response) {
				//scope.log.response("Upload response:", response);
				//done();
				
				var updateStack = new pstack();
				
				_.each(response, function(item) {
					
					// Replace with a CNAME domain and remove the protocol
					if (scope.options.cdn.alias.libs) {
						if (item && item.data && item.data.cdnpath) {
							item.remote	= scope.options.cdn.alias.libs+'/'+item.data.cdnpath;
						}
					}
					
					// Save
					updateStack.add(function(completed) {
						var cacheData	= {
							date:		new Date(),
							md5:		item.data.md5,
							groupMd5:	gmd5,
							minified:	false,
							file:	{
								local:		item.data.local,
								cdnpath:	item.data.cdnpath,
								staticpath:	item.data.staticpath
							},
							remote:		item.remote
						};
						cacheData = _.extend(cacheData, options);
						
						scope.mongo.update({
							collection:	'cdncache',
							query:	{
								type:				'cdn-cache',
								domain:				scope.options.cdn.alias.libs,
								'file.staticpath':	item.data.staticpath
							},
							data:		{
								$set:	cacheData
							}
						}, function() {
							completed();
							return true;
						});
						return true;
					});
					return true;
				});
				
				updateStack.start(done);
				
				return true;
			});
			return true;
			
		});
		return true;
	});
	
	opStack.start(callback);
	
};

ftl.prototype.render = function(filename, data, params, callback) {
	var scope	= this;
	/*
	// Get the file list
	if (libs) {
		var includes	= scope.bowerdep.getFiles(libs);
	}
	*/
	
	//this.log.info("path.normalize(this.root+'/'+filename)", path.normalize(this.root+'/'+filename));
	
	var filename	= path.normalize(this.root+'/'+filename);
	
	var cacheSign	= {
		filename:	filename,
		data:		data
	};
	
	if (data.cache && this.cache.exists(cacheSign)) {
		callback(this.cache.get(cacheSign));
	} else {
		
		/*
			Load the file's content
			Parse with the internal plugins
			Parse with nunjucks
		*/
		
		//scope.log.log("render", "data", data);
		
		if (data.nunjucksFirst) {
			fstool.file.read(filename, function(html) {
				
				var pluginStack	= new pstack({async:false, progress:false});
				
				pluginStack.add(function(done) {
					// Render with nunjucks
					html = nunjucks.renderString(html, data);
					
					//scope.log.log("renderString", "html", html);
					//scope.log.log("renderString", "data", data);
					//scope.log.log("renderString", "html", html);
					
					done();
					return true;
				});
				
				_.each(scope.renderPlugins, function(renderPlugin) {
					
					pluginStack.add(function(done) {
						renderPlugin(html, data, params, function(response) {
							html	= response;
							done();
							return true;
						});
					});
					return true;
				});
				
				pluginStack.start(function() {
					
					// Save in the cache
					scope.cache.set(cacheSign, html, scope.options.TTL.view*1000)
					
					callback(html);
					return true;
				});
				return true;
			});
			
		} else {
			fstool.file.read(filename, function(html) {
				
				var pluginStack	= new pstack({async:false, progress:false});
				
				_.each(scope.renderPlugins, function(renderPlugin) {
					
					pluginStack.add(function(done) {
						renderPlugin(html, data, params, function(response) {
							html	= response;
							//scope.log.log("render", "response", response);
							done();
							return true;
						});
						return true;
					});
					return true;
				});
				
				pluginStack.start(function() {
					
					// Render with nunjucks
					html = nunjucks.renderString(html, data);
					
					// Save in the cache
					scope.cache.set(cacheSign, html, scope.options.TTL.view*1000)
					
					callback(html);
					return true;
				});
				return true;
			});
		}
		
		
		/*
		// Get the template data
		fstool.file.read(filename, function(content) {
			
			var pluginStack	= new pstack({async:false, progress:false});
			
			_.each(scope.renderPlugins, function(renderPlugin) {
				
				pluginStack.add(function(done) {
					renderPlugin(content, data, params, function(response) {
						content	= response;
						scope.cache.set(cacheSign, response, scope.options.TTL.view*1000)
						done();
					});
				});
			});
			
			pluginStack.start(function() {
				callback(content);
			});
		});
		*/
	}
};

ftl.prototype.cliArgs = function() {
	return getCLIArgs();
};

// Register an add-on
ftl.prototype.addon = function(type, name, value) {
	if (_.isUndefined(value)) {
		if (!this.modules.hasOwnProperty(type)) {
			return null;
		}
		return this.modules[type][name];
	}
	if (!this.modules.hasOwnProperty(type)) {
		this.modules[type]	= {};
	}
	
	this.modules[type][name]	= value;
	return this;
};

// Register an cron job
ftl.prototype.cron = function(type, interval, callback) {
	this.crons[type]	= callback;
	this.intervals['cron-'+type]	= setInterval(function() {
		callback();
		return true;
	}, interval);
	return this;
};

// Register a route
ftl.prototype.addRoute = function(routeSettings) {
	var scope	= this;
	
	this.routes.push(routeSettings);
	
	_.each(routeSettings.type, function(type) {
		switch (type) {
			default:
			case "GET":
				type	= 'get';
			break;
			case "POST":
				type	= 'post';
			break;
			case "PUT":
				type	= 'put';
			break;
			case "DELETE":
			case "DEL":
				type	= 'delete';
			break;
		}
		
		
		var routeExec	= function(req, res) {
			
			req.routePathname	= routeSettings.pathname;
			
			var responded	= false;
			
			var params		= _.extend({}, req.query, req.body, req.params);
			var paramsCopy	= JSON.parse(JSON.stringify(params));	// For logging
			var processStack = new pstack();
			
			// Apply each before-process plugin, to edit the parameters
			_.each(scope.plugins['before-process'], function(plugin) {
				processStack.add(function(done) {
					plugin(routeSettings, params, req, res, function(error, details) {
						if (error) {
							scope.output(details, req, res, 200, routeSettings.output, routeSettings);
							// Go no further
							//console.log("STOP THE STACK!");
							responded	= true;
							done(false);
							return false;
						} else {
							if (details && details.params) {
								params	= details.params;
							}
							done();
							return true;
						}
					});
				});
				return true;
			})
			processStack.start(function() {
				if (!responded) {
					// If we're still going (no error or interuption), apply the before-response plugins, to modify the output
					routeSettings.method(params, req, res, function(response, status) {
						_.each(scope.plugins['before-response'], function(plugin) {
							response	= plugin(response, params, routeSettings);
							return true;
						})
						
						// Calculate how long it took to process the request
						res._requestEnded	= new Date();
						res._latency		= res._requestEnded.getTime()-res._requestStarted.getTime();
						
						// Respond
						scope.output(response, req, res, status, routeSettings.output, routeSettings);
						
						if (scope.options.latency && scope.options.latency.requests && res._latency > scope.options.latency.requests) {
							
							scope.log.sys("REQ LATENCY ALERT: ", scope.log.format('bg.magenta', res._latency+"ms"), " on ", scope.log.format('bg.magenta', routeSettings.pathname));
							
							scope.mongo.insert({
								collection:	'latencylogs',
								data:	{
									id:			scope.sid(),
									type:		'route',
									date:		new Date(),
									ms:			res._latency,
									data:		routeSettings,
									params:		paramsCopy,
									bookmarked:	false
								}
							}, function() {});
						}
						
						return true;
					});
				}
				return true;
			});
			return true;
		}
		
		
		if (routeSettings.upload) {
			var upload = multer({ dest: 'uploads/' });
			scope.app[type](routeSettings.pathname, upload.single(routeSettings.upload.name), function (req, res) {
				routeExec(req, res);
				return true;
			});
		} else {
			scope.app[type](routeSettings.pathname, function (req, res) {
				routeExec(req, res);
				return true;
			});
		}
	});
	return this;
};

// Register a render plugin
ftl.prototype.addRenderPlugin = function(renderCallback) {
	this.renderPlugins.push(renderCallback);
	return this;
};

// Register a render plugin
ftl.prototype.addPlugin = function(type, callback) {
	this.plugins[type].push(callback);
	return this;
};


ftl.prototype.getCdnContainerData = function(container, callback) {
	var scope	= this;
	
	if (this.cache.exists({cdn_container:container})) {
		callback(this.cache.get({cdn_container:container}));
	} else {
		this.cdnClient.getContainer(container, function (err, containerData) {
			containerData.url 			= containerData.cdnUri;
			scope.cache.set({cdn_container:container}, containerData, 1000*60*60*72);	// 72h
			callback(containerData);
		});
	}
	return this;
};

// Upload to the CDN
ftl.prototype.upload = function(container, files, callback) {
	var scope	= this;
	
	if (_.isArray(files) && !_.isArray(files[0])) {
		files = [files];
	}
	var uploadedFiles	= [];
	
	
	
	var stack = new pstack({
		progress:	'Uploading...',
		async:		false
	});
	
	_.each(files, function(filePair) {
		
		//console.log("filePair: ",filePair);
		
		stack.add(function(done) {
			var options = {
				container:	container,
				remote: 	filePair[1],
				local: 		filePair[0],
				metadata:	{
					uploaded_on:	new Date().toString()
				}
			};
			
			//scope.log.response("options", options);
			
			// Remove the file first
			//console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','deleting')+' '+scope.log.format('color.yellow',options.remote));
			scope.cdnClient.removeFile(options.container, options.remote, function(err, result) {
				if (err) {
					console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','deleting')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.red',err.message));
				} else {
					console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','deleting')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.green','success'));
				}
				//scope.log.info("Upload err", err, result);
				
				//console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CDN Upload')+' '+scope.log.format('color.yellow',options.remote));
				
				var readStream 		= fs.createReadStream(options.local);
				var writeStream 	= scope.cdnClient.upload(options);
				
				readStream.on('error', function(err) {
					//scope.log.response("readStream error", err);
					console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CDN Upload')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.red','failed'));
					scope.log.error(err);
					callback(err);
					return true;
				});
				writeStream.on('error', function(err) {
					//scope.log.response("writeStream error", err);
					console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CDN Upload')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.red','failed'));
					scope.log.error(err);
					callback(err);
					return true;
				});
				
				writeStream.on('success', function(file) {
					scope.getCdnContainerData(options.container, function(data) {
						uploadedFiles.push({
							public:		options.remote,
							local:		options.local,
							remote:		data.url+"/"+options.remote,
							data:		filePair[2]
						});
						
						console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CDN Upload')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.green','success'));
						
						// If it's a file that has CORS issue, let's make it CORS compatible
						var corsExt = ['.html'];
						if (scope.cfcors && _.contains(corsExt, path.extname(options.local))) {
							
							//console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CORS Headers')+' '+scope.log.format('color.yellow',options.remote));
							
							scope.cfcors.cors({
								container:	options.container,
								file:		options.remote
							}, function(response) {
								
								console.log(scope.log.format('bg.blue','~ Upload')+' '+scope.log.format('bg.red','CORS Headers')+' '+scope.log.format('color.yellow',options.remote)+' '+scope.log.format('bg.green','success'));
								
								done();
								return true;
							});
						} else {
							done();
						}
						
						return true;
						
						//callback(false, data.url+"/"+options.remote);
					});
					return true;
				});
				
				readStream.pipe(writeStream);
				return true;
			});
			return true;
		});
	});
	
	stack.start(function() {
		callback(uploadedFiles);
		return true;
	});
	
	return this;
};

ftl.prototype.md5 = function(input) {
	var md5sum = nodecrypto.createHash('md5');
	md5sum.update(input);
	return md5sum.digest('hex');
}
ftl.prototype.uuid = function() {
	return this.md5(uuid.v4());
}
ftl.prototype.sid = function() {
	return shortid.generate();
}

// output
ftl.prototype.output = function(response, req, res, status, format, routeSettings) {
	if (!status) {
		status	= 200;
	}
	var outputMethod	= this.addon('output', format);
	if (typeof outputMethod == 'function') {
		outputMethod(response, req, res, status, routeSettings);
	} else {
		res.set("Content-Type", "application/json");
		res.status(status).send(JSON.stringify(response, null, 4));
	}
	return this;
};

ftl.prototype.errorResponse = function(response, data) {
	return _.extend({
		error:		true,
		message:	response
	},data);
	return this;
};

module.exports = ftl;
