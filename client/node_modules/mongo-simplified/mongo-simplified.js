var _ 			= require('underscore');
var mongodb		= require('mongodb');
var ObjectID	= mongodb.ObjectID;
var respool		= require('respool');
var pstack 		= require('pstack');
var fs 			= require('fs');

function mongo(options) {
	this.options = _.extend({
		host:		"127.0.0.1",
		port:		27017,
		database:	"gamify",
		poolSize:	10,
		poolMin:	1,
		latency:	{
			max:		100,
			onAlert:	function(op, options) {}
		}
	},options);
	
	//console.log(">>>>>>>>>>>>>>>>>>>>>> %MONGO OPTIONS",JSON.stringify(options,null,4));
	
	this.collections = {};
}
mongo.prototype.timer = function(op, options) {
	var scope 		= this;
	var started		= new Date().getTime();
	
	return {
		stop:	function() {
			var ms	= new Date().getTime()-started;
			if (scope.options.latency && scope.options.latency.onAlert && scope.options.latency.max && ms >= scope.options.latency.max) {
				scope.options.latency.onAlert(ms, op, options);
			}
		}
	}
}
mongo.prototype.init = function(callback) {
	var scope 		= this;
	
	this.pool	= new respool({
		count:	this.options.poolSize,
		min:	this.options.poolMin,
		async:	false,
		create:	function(done) {
			if (scope.options.string) {
				var url = scope.options.string;
			} else {
				var url = 'mongodb://'+scope.options.host+':'+scope.options.port+'/'+scope.options.database;
			}
			
			
			var mongoOptions	= {
				//mongos: 			true,
				//uri_decode_auth:	true
				'thread-affinity':	true
			};
			
			
			if (scope.options.ssl) {
				mongoOptions.server	= {
					sslValidate:true,
					sslCA:		[fs.readFileSync(scope.options.ssl.ca)],
					sslKey:		fs.readFileSync(scope.options.ssl.key),
					sslCert:	fs.readFileSync(scope.options.ssl.cert),
					sslPass:	scope.options.ssl.sslPass
				}
			}
			
			
			var db = mongodb.MongoClient;
			db.connect(url, mongoOptions, function (error, client) {
				if (error) {
					throw error;
					done(false);
				}
				done(client);
			});
			return true;
		}
	});
	this.pool.init(function() {
		console.log("MongoDB Pool Started.");
		callback();
		return true;
	});
	return this;
}
mongo.prototype.open = function(collectionName, callback) {
	callback(this.pool.instance().collection(collectionName));
	return this;
}
mongo.prototype.remove = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{}
	},options);
	
	var timer = scope.timer('remove', options);
	
	this.open(options.collection, function(collection) {
		collection.remove(options.query, function(err, removed) {
			callback(removed);
			
			timer.stop();
			
			return true;
		});
		
		return true;
	});
	return this;
};
mongo.prototype.aggregate = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		match:			false,
		unwind:			false,
		group:			false,
		project:		false,
		rules:			[]
	},options);
	
	var timer = scope.timer('aggregate', options);
	
	
	this.logQuery(_.extend({
		type:		'aggregate'
	},options));
	
	this.open(options.collection, function(collection) {
		if (options.rules.length > 0) {
			// New structure
			
			collection.aggregate(options.rules, function(err, response) {
				
				//console.log(">>>>>>>>>", options.rules, err, response);
				
				//console.log("\n\n------------------------------------------------------------------["+options.collection+"]\n", JSON.stringify(options.rules, null, 4));
				if (err) {
					console.log("ERROR:", err);
					return false;
				}
				callback(response);
				
				timer.stop();
				
				return true;
			});
		} else {
			// Deprecated, compatibility mode with old code
			collection.aggregate(_.compact([options.project,options.match,options.unwind,options.group]), function(err, response) {
				callback(response);
				
				timer.stop();
				
				return true;
			});
		}
		return true;
	});
	return this;
};
mongo.prototype.distinct = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		key:			"uuid",
		query:			{}
	},options);
	
	var timer = scope.timer('distinct', options);
	
	this.logQuery(_.extend({
		type:		'distinct'
	},options));
	
	this.open(options.collection, function(collection) {
		collection.distinct(options.key, options.query, function(err, response) {
			callback(response);
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
};
mongo.prototype.count = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('count', options);
	
	this.logQuery(_.extend({
		type:		'count'
	},options));
	
	this.open(options.collection, function(collection) {
		
		collection = collection.find(options.query,{},options.options);
		
		collection.count(function(err, count) {
			callback(count);
			
			timer.stop();
			
			return true;
		});
		
		return true;
	});
	return this;
};
mongo.prototype.paginationInfo = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		perpage:		10,
		page:			1
	},options);
	
	var timer = scope.timer('paginationInfo', options);
	
	this.open(options.collection, function(collection) {
		
		collection = collection.find(options.query,options.fields,options.options);
		
		collection.count(function(err, count) {
			var np	= Math.ceil(count/options.perpage);
			
			callback({
				perpage:	options.perpage,
				total:		count,
				pages:		np
			});
			
			timer.stop();
			
			return true;
		});
		
		return true;
	});
	return this;
};
mongo.prototype.paginate = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		perpage:		10,
		page:			1
	},options);
	
	var timer = scope.timer('paginate', options);
	
	this.paginationInfo(options, function(response) {
		response.current	= options.page;
		scope.find(options, function(response2, err) {
			callback({
				pagination:	response,
				data:		response2
			}, err);
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
};

mongo.prototype.get = function(options, callback) {
	options.limit = 1;
	
	var timer = this.timer('get', options);
	
	this.find(options, function(response) {
		if (response && response.length) {
			callback(response[0]);
		} else {
			callback(false);
		}
		
		timer.stop();
		
		return true;
	});
	return this;
};

mongo.prototype.batchFind = function(options, callback, onComplete) {
	var scope 		= this;
	
	options	= _.extend({
		progress:	false,
		async:		false,
		perpage:	100,
		start:		1,
		stop:		false
	}, options);
	
	scope.paginationInfo(options, function(pagination) {
		
		//console.log(">>pagination",pagination);
		
		var stack = new pstack({
			progress:	options.progress,
			async:		options.async
		});
		
		var until = pagination.pages;
		
		if (options.stop) {
			until	= options.stop-1;
		}
		
		var i;
		for (i=options.start;i<=until;i++) {
			
			stack.add(function(done, p) {
				scope.paginate(_.extend(options, {
					page:	p.i
				}), function(response, err) {
					callback(response.data, done, {
						total:		pagination.total,
						page:		p.i,
						pages:		pagination.pages,
						perpage:	options.perpage,
						progress:	(p.i/pagination.pages*100).toFixed(2)+'%'
					}, err);
					return true;
				});
				return true;
			}, {i:i});
		}
		
		stack.start(function(){
			onComplete();
			return true;
		});
		
		return true;
	});
	return this;
};


mongo.prototype.fastBatchFind = function(options, callback, onComplete) {
	var scope 		= this;
	
	options	= _.extend({
		collection:	'',
		query:		{},
		progress:	false,
		onProgress:	false,
		after:		false,
		size:		100,
		total:		0
	}, options);
	
	var stack	= new pstack();
	
	if (!options.count) {
		stack.add(function(done) {
			scope.count({
				collection:	options.collection,
				query:		options.query
			}, function(count) {
				console.log(">> ",count+" items found.");
				console.log(">> ",options.size+" items per batch.");
				console.log(">> ",Math.ceil(count/options.size)+" steps required.");
				options.count	= count;
				done();
			});
		});
	}
	
	stack.add(function(done) {
		
		//options.total	= 0;
		
		if (options.after) {
			options.query	= _.extend(options.query, {
				_id:	{
					$gt:	options.after
				}
			});
		}
		
		//console.log(">> query: ",options.query);
		
		scope.find({
			collection:	options.collection,
			query:		options.query,
			limit:		options.size,
			sort:	{
				_id:	1
			}
		}, function(response, err) {
			
			//console.log(">> Current Total: ", options.total);
			//console.log(">> Response size: ", response?response.length:'null (no response)');
			
			//console.log("fastBatchFind response", JSON.stringify(response,null,4));
			if (!response || response.length==0) {
				//console.log(">> No documents found ("+options.collection+").", response, err);
				onComplete();
			} else {
				
				options.total	+= response.length;
				
				//console.log(">> New Total: ", options.total);
				
				if (options.progress) {
					console.log(">> ",options.progress, (options.total/options.count*100).toFixed(2)+'%');
					if (options.onProgress) {
						options.onProgress(options.total/options.count*100);
					}
				}
				
				//console.log("fastBatchFind options", JSON.stringify(options,null,4));
				
				callback(response, function() {
					if (response.length>0) {
						options.after	= response[response.length-1]._id;
						scope.fastBatchFind(options, callback, onComplete);
					}
				});
			}
		});
	});
	
	stack.start(function() {
		
	});
	
	
	//console.log("fastBatchFind options", JSON.stringify(options,null,4));
	
	
	
	return this;
};

mongo.prototype.find = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		fields:			{},
		options:		{},
		page:			false,
		perpage:		10,
		limit:			false,
		skip:			false,
		sort:			false
	},options);
	
	var timer = scope.timer('find', options);
	
	
	this.logQuery(_.extend({
		type:		'find'
	},options));
	
	this.open(options.collection, function(collection) {
		
		collection = collection.find(options.query,options.fields,options.options);
		
		if (options.page) {
			options.limit 	= options.perpage*1;
			options.skip	= options.perpage*options.page-options.perpage;
		}
		
		if (options.limit) {
			collection = collection.limit(options.limit);
		}
		if (options.skip) {
			collection = collection.skip(options.skip);
		}
		
		if (options.sort) {
			collection = collection.sort(options.sort);
		}
		collection.toArray(function(err, docs) {
			callback(docs, err);
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.insert = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		data:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('insert', options);
	
	this.open(options.collection, function(collection) {
		collection.insert(options.data,options.options, function() {
			
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.update = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		data:			{},
		options:		{
			multi:	true,
			upsert:	true
		}
	},options);
	
	var timer = scope.timer('update', options);
	
	this.open(options.collection, function(collection) {
		collection.update(options.query,options.data,options.options, function() {
			
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.createIndex = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		index:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('createIndex', options);
	
	this.open(options.collection, function(collection) {
		collection.createIndex(options.index, options.options, function() {
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.addToSet = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		path:			"",
		data:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('addToSet', options);
	
	var _update 	= {
		$addToSet:	{}
	};
	_update['$addToSet'][options.path] = options.data;
	
	this.open(options.collection, function(collection) {
		collection.update(options.query,_update,options.options, function() {
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.pull = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		path:			"",
		data:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('pull', options);
	
	
	var _update 	= {
		$pull:	{}
	};
	_update[$pull][options.path] = options.data;
	
	
	this.open(options.collection, function(collection) {
		collection.update(options.query,_update,options.options, function() {
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.updateSub = function(options, callback) {
	var scope 		= this;
	
	options			= _.extend({
		collection:		"",
		query:			{},
		path:			"",
		data:			{},
		options:		{}
	},options);
	
	var timer = scope.timer('updateSub', options);
	
	var i;
	var _query 		= {};
	var _update 	= {};
	
	_query[options.path] = {
		$elemMatch:	data
	}
	
	_update[$set] = {};
	for (i in data) {
		_update[$set][options.path+".$."+i]	= data[i];
	}
	
	this.open(options.collection, function(collection) {
		collection.update(_query,_update,options.options, function() {
			callback();
			
			timer.stop();
			
			return true;
		});
		return true;
	});
	return this;
}
mongo.prototype.logQuery = function(options, callback) {
	var scope 		= this;
	return false;
	
	if (options.type=='aggregate') {
		options =	_.extend({}, options, {
			rules:	_.map(options.rules, function(item) {
				return JSON.stringify(item);
			})
		});
	} else {
		if (options.query) {
			options = _.extend({}, options, {
				query:	JSON.stringify(options.query)
			});
		}
		if (options.sort) {
			options = _.extend({}, options, {
				sort:	JSON.stringify(options.sort)
			});
		}
		
	}
	
	this.open('query_logger', function(collection) {
		collection.insert(options,{}, function(err, response) {
			if (err) {
				console.log("LOG ERROR: ", err);
				console.log("Debug:",options);
			}
			return true;
		});
		return true;
	});
	return this;
}

module.exports = mongo;