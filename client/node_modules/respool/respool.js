
var _ 			= require('underscore');
var path 		= require('path');
var fs 			= require('fs');
var pstack 		= require('pstack');

var respool	= function(options, callback) {
	
	this.options	= _.extend({
		count:		10,
		async:		true,
		progress:	false,
		min:		false,
		create:		function(callback) {
			callback(this);
		}
	}, options);
	
	this.instances	= [];
	this.counts		= [];
	
	if (this.options.min && this.options.min > this.options.count) {
		console.log("ERROR (respool): min can't be higher than count.");
		this.options.min = false;	// Disabled to avoid the callback never being executed
	}
	
};
respool.prototype.init = function(callback) {
	var scope		= this;
	
	var stack	= new pstack({
		async:		this.options.async,
		progress:	this.options.progress
	});
	
	if (!this.options.min) {
		// Execute the callback when everything is started
		var i;
		for (i=0;i<this.options.count;i++) {
			stack.add(function(done) {
				scope.options.create(function(instance) {
					scope.instances.push(instance);
					scope.counts.push(0);
					done();
				});
			});
		}
		stack.start(callback);
	} else {
		// Execute the call back when some of them are started
		var started = 0;
		var i;
		for (i=0;i<this.options.count;i++) {
			stack.add(function(done) {
				scope.options.create(function(instance) {
					scope.instances.push(instance);
					scope.counts.push(0);
					started++;
					done();
					if (started==scope.options.min) {
						callback();
					}
				});
			});
		}
		stack.start(function() {});
	}
	
	
	return this;
}
respool.prototype.instance = function() {
	// Find the min
	var i;
	var l		= this.counts.length;
	var min		= Number.POSITIVE_INFINITY;
	var index	= false;
	for (i=0;i<l;i++) {
		if (this.counts[i] < min) {
			min		= this.counts[i];
			index	= i;
		}
	}
	this.counts[index]++;
	return this.instances[index];
}

module.exports = respool;
